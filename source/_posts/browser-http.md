---
title: 从 http0.9 到 http3 的进化史
date: 2020-06-11 15:36:42
tags:
  - http
categories:
  - [http]
excerpt: HTTP 协议在我们的生活中随处可见，打开手机或者电脑，只要你上网，不论是用安卓机还是ios、不管是 mac 还是 windows、不论是浏览器还是 APP、不论是网上冲浪、刷抖音玩快手亦或是玩游戏，都离不开 HTTP，它一直在为你默默服务。所以这篇文章就梳理一下 HTTP 的发展史，它是怎么形成了如今的样子。
---

## HTTP/0.9

在互联网初期，整个网络世界比较简单，网络上共享的绝大数资源都是纯文本，所以第一版的 HTTP 协议也采用的纯文本格式，并且设想系统中的文档都是只读的，所以只设计了 GET 请求从服务器上获取 HTML 文档。同时因为需要传输的资源并不多，在服务器返回响应之后立即关闭 TCP 连接。当时的 HTTP 协议有这几个特点：

- 只有 GET 请求且只有请求行，并没有请求投请求体；
- 服务器也没有响应头信息，只简单的返回数据；
- 因为都是 HTML 格式的文件，所以返回的内容是以 ASCII 字符流的形式传输的。

然后我们看一下 HTTP/0.9 的一个请求过程：

- 因为 HTTP 基于 TCP/IP 协议的，所以客户端需要先通过 TCP 的三次握手和服务器建立 TCP 连接；
- 建立好连接之后，会发送一个 HTTP 的 GET 请求行信息，如 `GET /index.html` 用来获取资源；
- 服务器收接受到请求之后，根据请求路径找到对应的 HTML 资源文件，并将数据以 ASCII 字符流的形式返回给客户端；
- 服务器端发送完毕后，即马上四次挥手断开 TCP 连接。

## HTTP/1.0

随着技术的发展，计算机多媒体技术也有很大的进步，慢慢又出现了图片、音频、视频，还有 JavaScript、CSS 等不同类型的文件，但是 HTTP/0.9 显然不能满足新的需要，所以为了支持多媒体技术，增加了请求头和响应头用来进行协商，做了一些改进，比如：

- 为了支持多种类型文件的解析，做针对性的处理，增加了请求头字段 accept，每种文件的编码形式也可能不一样，为了能准确的读取文件，增加了请求头字段 accept-Charset，响应头字段 content-type 的返回信息将两者合并了；
- 由于应用的复杂化，所以文件数量越来越多、文件体积越来越大，为了减轻传输性能，所以让服务器对数据进行压缩之后再进行传输，增加了请求头字段 accept-encoding，服务器增加了响应头字段 content-encoding。同时为了减轻服务端的压力，也引入了 Cache 机制，用来缓存已经下载过的数据；
- 另外，因为互联网是全球范围的，所以还需要提供国际化支持，服务器对不用地区提供不能的版本，所以还需要浏览器向服务器提供所需的语言版本，增加了请求头 accept-language；
- 对于服务器来说，有些请求可能处理不了或者处理出现了问题，这时候就需要和浏览器同步信息，所以引入了状态码，用来标记可能出现的错误原因；
- 增加了 HEAD、POST 等新的请求方法；
  ...

虽然 HTTP/1.0 增加了很多东西，但它并没有实际的约束力，只是一份参考文档。因为各个浏览器厂商都在按照自己的意愿设计进行激烈的竞争，并不具有统一性。

## HTTP/1.1

1995 年，网景 Netscape Navigator 和微软的 Internet Explorer 开展了著名的"浏览器大战"，都希望占据主导地位，结果大家都知道，最后微软赢得胜利。但这次大战极大的推动了 Web 的发展，在"浏览器大战"结束之后的 1999 年，HTTP 1.1 发布了 RFC 文档，成为一份正式的标准。

HTTP/1.1 在 HTTP/1.0 的基础上做了一些新的进步，主要的变更点有：

**持久连接**
HTTP/1.0 每进行一次通信，都要经过三个阶段：建立 TCP 连接、HTTP 请求和响应数据、断开 TCP 连接。随着浏览器的普及，页面图片文件增多，引用文件增多，一个页面可能达到几百个外部引用资源文件，基于这种情况，如果再下载的时候还是每次都需要建立 TCP 连接，就会增加很多无用的开销。所以为了解决这个问题，HTTP/1.1 增加了持久连接的方法，允许在一个 TCP 连接上传输多个 HTTP 请求和响应，只要浏览器和服务器没有明确要断开，那么这个连接就会一直保持。但是下一个 HTTP 请求只能等到上一个 HTTP 响应到达客户端才能发送，如果上一个 HTTP 一直没有响应，那么后续的 HTTP 请求就会一直等待。

持久连接在 HTTP/1.1 中是默认开启的，如果你想取消持久连接，可以在请求头中加上 `Connection: close`。目前浏览器中对于同一个域名，默认允许建立 6 个 TCP 连接。

**增加 Host 头**
在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机的技术发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己单独的域名，但是这些单独的域名共用同一个 IP 地址。因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。

**响应数据分块**
在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，比如 Content-Length: 100，这样浏览器就可以根据设置的数据大小来接收数据。但是随着服务器的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终大小是多少，浏览器也不知道什么时候能接收完。所以 HTTP/1.1 通过引入 `Chunk transfer` 机制来解决这个问题，服务器会将数据分割何曾若干大小的块，每个数据块发送时附上上个数据块的长度，最后使用一个零长度的块作为发送完成的标志。

**Cookie**
解决无状态的问题。

## HTTP/2

HTTP/1.1 发布之后十多年，整个互联网直接发展迅猛，导致人们对 HTTP 有些不满，主要是连接速度慢，但 HTTP/1.1 也没有任何改变进步。然后 Google 就开发了自己的浏览器 Chrome，然后推出了新的 SPDY 协议，并应用于 Chrome 中，随着 Chrome 的市场占用率越来越高，互联网标准化组织以 SPDY 为基础开始指定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2。

HTTP/2 主要解决了 HTTP/1.1 中几个问题：

1. **慢启动**
   一旦一个 TCP 连接建立之后，就进入了发送数据的状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快，直到发送数据的速度达到一个理想的状态，我们把这个过程称为慢启动。慢启动是为了减少网络拥塞的一种策略，是不能改变的。

   之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JS 文件，这些文件通常在 TCP 连接建立好之后就要发起请求，但是这个过程是慢启动，所以耗费的时间比正常的要多，这样就推迟了宝贵的首次渲染页面的时长。

2. **开启多条 TCP 连接**
   对于同一个域名，默认可以开启 6 个 TCP 连接。当系统同时建立多条 TCP 连接时，在带宽充足的情况下，每条连接发送或者接收速度会慢慢增加，而一旦带宽不足时，这些 TCP 连接又会减慢发送或接收速度，比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 \* 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。

   这样就出现了一个问题，因为有的 TCP 连接下载的时一些关键资源，如 CSS 文件、JS 文件，而有的 TCP 连接下载是一些图片、音频等普通资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就会影响那些关键资源的下载速度。

3. **队头阻塞**
   在 HTTP/1.1 中使用持久连接时，虽然能共用一个 TCP 连接，但是在一个连接的同一时刻只能处理一个请求，在当前请求没有结束之前，其他请求只能处于阻塞状态，在等待的过程中带宽、CPU 都白白浪费了。

为了对 HTTP/1.1 中性能进行优化，HTTP/2 做了一些改进，其中最重要的就是多路复用。

### 多路复用

虽然 TCP 有慢启动和竞争带宽的问题，但由于是 TCP 本身的机制导致的，不能改变，只能想办法规避。基于此，HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样在整个页面资源的下载过程中只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽的问题。另外，它也实现了并行请求，任何时候都可以将请求发送给服务器，而不需要等待上一下请求完成，服务器也可以随时返回处理好的请求资源，解决了队头阻塞的问题。

那么 HTTP/2 是如何实现的呢？其实是增加了一耳光二进制分帧层。

- 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
- 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
- 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
- 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
- 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
- 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求

### 请求的优先级

我们知道浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器，这对于用户体验来说是非常不友好的。

为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。

### 服务器推送

除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。

### 头部压缩

无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。
