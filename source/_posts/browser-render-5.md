---
title: 页面的渲染过程
date: 2020-06-08 15:49:16
tags:
  - 浏览器
  - 渲染
categories:
  - [渲染]
excerpt: 页面的渲染过程是个复杂且有序的过程，这篇文章是我对于这块知识的一个系统梳理和总结。
---

我们在具体了解页面的渲染流程之前，先来对浏览器架构有个基本的认识。

## 浏览器架构

在最初浏览器设计出来的时候，它其实是单进程的结构，包括了页面线程、网络线程以及其他线程，页面线程主要负责页面的渲染、JS 的运行、插件等。但基于这种架构的设计非常不稳定，也不流畅，因为如果一个插件出了问题就会导致整个浏览器崩溃，而且也因为一个页面线程负责了很多内容，所以模块的执行需要按需进行，容易导致阻塞、浏览器卡顿，用户体验不佳。

后来经过一系列的优化改进，有了现在的这种浏览器多进程架构，最新的 Chrome 浏览器包括：1 个浏览器主进程、1 个 GPU 进程、1 个网络进程、多个渲染进程、多个插件进程。

1. **浏览器主进程(Browser Process)**：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能；
2. **渲染进程(Render Process)**：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下；
3. **GPU 进程(GPU Process)**：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 页面都采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程；
4. **网络进程(Network Process)**：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直到最近才独立出来，成为一个单独的进程；
5. **插件进程(Plugin Process)**：主要负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响；

## 构建 DOM 树

我们请求资源，其实是在网络进程中进行的，请求到数据之后，浏览器主进程会通知渲染进程，然后在网络进程和渲染进程之间建立 IPC 通信，将服务器返回的数据发给渲染进程，从而开始了浏览器的渲染流程。

首先第一步便是构建 DOM 树，但为什么要构建 DOM 树呢？DOM，文档对象模型，是 HTML 和 XML 文档的编程接口，它通过将文档进行结构化，并且定义了对结构的访问方式，使得可以通过 JS 改变改变文档的结构、样式和内容。所以它将页面和脚本连接了起来。知道了构建 DOM 树的原因，接下来就来看看如何渲染引擎是如何构建 DOM 树的。

在渲染引擎内部，有一个叫做 HTML 解析器（HTML Parser）的模块，它主要负责将 HTML 字节流转换为 DOM 结构。

### 标记化：词法分析

```
<html>
<body>
  <div>hello world</div>
</body>
<html>
```

如上一段简单的代码，在从网络进程传输过来的时候就是字节流的形式，需要通过分词器先将字节流转换为一个个的 Token，生成的 Token 分为两种形式，Tag Token 和 文本 Token。上述 HTML 代码通过词法分析生成的 Token 可以表示为：

`startTag:html`、`startTag:body`、`startTag:div`、`hello world`、`endTag:div`、`endTag:body`、`endTag:html`。

### 建树：语法分析

在 HTML 解析器中维护了一个 Token 栈，该结构主要用来维护父子节点以及标签，它会按照一定的规则将上述流程生成的 Token 压入栈中：

- HTML 解析器默认会创建一个根为 document 的空 DOM 结构；
- 如果压入栈中的是 startTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中；
- 如果遇到的是文本 Token，那么会创建一个文本节点，并将该节点加入 DOM 树，它的父节点就是当前栈顶 Token 所对应的 DOM 节点，文本节点是不需要压入栈的；
- 如果遇到的是 endTag Token，HTML 解析器会查看 Token 栈顶的元素是否为匹配的 startTag Token，比如 startTag:div 和 endTag:div，如果是就将 startTag:div 从栈中弹出，表示该元素解析完成。

通过分词器产生的新 Token 不断的入栈和出栈，整个解析过程一直持续下去，直到分词器将所有字节流分词完成。

## 样式计算

### 格式化 CSS

CSS 样式来源主要有三种：

- 通过 link 引用的外部 CSS 文件；
- `<style>`标记内的 CSS；
- 元素的 style 属性内嵌的 CSS。

和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，因此渲染引擎接收到 CSS 文本之后第一件事情就是将其转化为一个结构化的对象，即 styleSheets。

在浏览器控制台能够通过 `document.styleSheets` 来查看这个最终的结构。当然，这个结构包含了以上三种 CSS 来源，为后面的样式操作提供了基础。

### 标准化 CSS

有一些 CSS 样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如 em->px,red->#ff0000,bold->700 等等。

### 计算出 DOM 树中每个节点的具体样式

现在样式的属性已被标准化了，也有了 DOM 树，那么接下来就需要计算 DOM 树中每个节点的样式属性了，如何计算呢？这就涉及到 CSS 的继承规则和层叠规则了。

- 首先是 CSS 继承。CSS 继承就是每个 DOM 节点都包含有父节点的样式，如果都没有设置，那么就会就会采用浏览器默认样式，也叫 UserAgent 样式；
- 然后是层叠，层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。

在计算完样式之后，所有的样式值会被挂在到 window.getComputedStyle 当中，也就是可以通过 JS 来获取计算后的样式，非常方便。

## 布局阶段

通过上面的过程，有了 DOM 树和样式，那么接下来就需要将样式填充到 DOM 树中，即布局树 Layout Tree。生成布局树的大体过程如下：

- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；
- 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

## 分层

通常页面中有很多复杂的效果，比如旋转缩放效果、页面滚动等等，如果由布局树直接生成目标图片的话，每当页面中有很小的改动，全部内容便需要重新绘制，非常影响页面的体验。为此，Chrome 团队提出了分层和合成的概念，即将一些可能经常变化等的属性，渲染为单独的图层，这样当属性改变时也只会改变当前图层，不会对其他图层产生影响，最后再将所有的图层合并起来。那么什么时候会产生新的图层呢？

1. 拥有层叠上下文属性的节点，如
   1. HTML 根元素本身；
   2. 普通元素设置 position 不为 static，且设置了 z-index 属性；
   3. 元素的 opacity 不为 1；
   4. 元素的 transform 不会 none；
   5. 元素的 isolation 是 isolate；
   6. will-change 指定的属性值为上面任意一个；
2. 需要剪裁的地方
   比如一个 div，你只给他设置 100 \* 100 像素的大小，而你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。

## 图层绘制

渲染引擎实现图层的绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。如下以百度首页为例，通过在 Chrome 开发者工具中选择`more tool ---> Layers`，就可以看到：

![tfTw0s.jpg](https://s1.ax1x.com/2020/06/08/tfTw0s.jpg)

## 栅格化（raster）操作

绘制列表生成好了之后便开始执行绘制操作，绘制操作是由渲染引擎中的合成线程来完成的，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。

在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。通常，栅格化过程都会使用 GPU 来加速生成，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。

## 合成与显示

栅格化操作完成后，合成线程会生成一个绘制命令，即"DrawQuad"，并发送给浏览器进程。
浏览器进程中的 viz 组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。
无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。
看到这里你也就是明白，当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。

## 总结

到这里基本上把渲染流程走完了，可以通过一张图来总结一下。

![tfO8ts.png](https://s1.ax1x.com/2020/06/08/tfO8ts.png)
